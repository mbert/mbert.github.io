<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../resources/report.css" type="text/css"/><link rel="shortcut icon" href="../resources/report.gif" type="image/gif"/><title>StaticMethodCandidateCheck.java</title><link rel="stylesheet" href="../resources/prettify.css" type="text/css"/><script type="text/javascript" src="../resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sevntu-checks</a> &gt; <a href="index.source.html" class="el_package">com.github.sevntu.checkstyle.checks.design</a> &gt; <span class="el_source">StaticMethodCandidateCheck.java</span></div><h1>StaticMethodCandidateCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.github.sevntu.checkstyle.checks.design;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.google.common.base.Optional;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;
import com.puppycrawl.tools.checkstyle.utils.ScopeUtil;

/**
 * Checks whether {@code private} methods can be declared as {@code static}.
 *
 * &lt;p&gt;The check has option {@code skippedMethods} which allows to specify the
 * list of comma separated names of methods to skip during the check. By default
 * the private methods which a class can have when it implements
 * &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/io/Serializable.html&quot;&gt;
 * Serializable&lt;/a&gt; are skipped: &quot;readObject, writeObject, readObjectNoData, readResolve,
 * writeReplace&quot;.
 *
 * &lt;p&gt;The following configuration allows to skip method {@code foo} and {@code bar}:
 * &lt;pre&gt;
 *     &amp;lt;module name=&amp;quot;NestedSwitchCheck&amp;quot;&amp;gt;
 *         &amp;lt;property name=&amp;quot;skippedMethods&amp;quot; value=&amp;quot;foo, bar&amp;quot;/&amp;gt;
 *     &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;Limitations:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Due to limitation of Checkstyle, there is no ability to distinguish
 * overloaded methods, so we skip them from candidates.
 * &lt;/li&gt;
 * &lt;li&gt;
 * Private methods called by reflection are not supported and have to be suppressed.
 * &lt;/li&gt;
 * &lt;/ul&gt;
 * @author Vladislav Lisetskiy
 * @since 1.17.0
 */
<span class="fc" id="L67">public class StaticMethodCandidateCheck extends AbstractCheck {</span>

    /** Warning message key. */
    public static final String MSG_KEY = &quot;static.method.candidate&quot;;

    /** Comma literal. */
    private static final String COMMA_SEPARATOR = &quot;,&quot;;

    /** Default method names to skip during the check. */
<span class="fc" id="L76">    private static final String[] DEFAULT_SKIPPED_METHODS = new String[] {</span>
<span class="fc" id="L77">        &quot;writeObject&quot;,</span>
<span class="fc" id="L78">        &quot;readObject&quot;,</span>
<span class="fc" id="L79">        &quot;readObjectNoData&quot;,</span>
<span class="fc" id="L80">        &quot;readResolve&quot;,</span>
<span class="fc" id="L81">        &quot;writeReplace&quot;,</span>
    };

    /** Array of tokens which are frames. */
<span class="fc" id="L85">    private static final int[] FRAME_TOKENS = new int[] {</span>
<span class="fc" id="L86">        TokenTypes.CLASS_DEF,</span>
<span class="fc" id="L87">        TokenTypes.METHOD_DEF,</span>
<span class="fc" id="L88">        TokenTypes.LITERAL_IF,</span>
<span class="fc" id="L89">        TokenTypes.LITERAL_FOR,</span>
<span class="fc" id="L90">        TokenTypes.LITERAL_WHILE,</span>
<span class="fc" id="L91">        TokenTypes.LITERAL_DO,</span>
<span class="fc" id="L92">        TokenTypes.LITERAL_CATCH,</span>
<span class="fc" id="L93">        TokenTypes.LITERAL_TRY,</span>
<span class="fc" id="L94">        TokenTypes.ENUM_DEF,</span>
<span class="fc" id="L95">        TokenTypes.ENUM_CONSTANT_DEF,</span>
<span class="fc" id="L96">        TokenTypes.STATIC_INIT,</span>
<span class="fc" id="L97">        TokenTypes.INSTANCE_INIT,</span>
<span class="fc" id="L98">        TokenTypes.CTOR_DEF,</span>
<span class="fc" id="L99">        TokenTypes.INTERFACE_DEF,</span>
<span class="fc" id="L100">    };</span>

    /** Method names to skip during the check. */
<span class="fc" id="L103">    private List&lt;String&gt; skippedMethods = Arrays.asList(DEFAULT_SKIPPED_METHODS);</span>

    /** Stack of sets of field names, one for each class of a set of nested classes. */
    private Frame currentFrame;

    /**
     * Sets custom skipped methods.
     * @param skippedMethods user's skipped methods.
     */
    public void setSkippedMethods(String skippedMethods) {
<span class="fc" id="L113">        final List&lt;String&gt; customSkippedMethods = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L114">        final String[] splitSkippedMethods = skippedMethods.split(COMMA_SEPARATOR);</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (String skippedMethod : splitSkippedMethods) {</span>
<span class="fc" id="L116">            customSkippedMethods.add(skippedMethod.trim());</span>
        }
<span class="fc" id="L118">        this.skippedMethods = customSkippedMethods;</span>
<span class="fc" id="L119">    }</span>

    @Override
    public int[] getAcceptableTokens() {
<span class="fc" id="L123">        return new int[] {</span>
<span class="fc" id="L124">            TokenTypes.CLASS_DEF,</span>
<span class="fc" id="L125">            TokenTypes.METHOD_DEF,</span>
<span class="fc" id="L126">            TokenTypes.LITERAL_IF,</span>
<span class="fc" id="L127">            TokenTypes.LITERAL_FOR,</span>
<span class="fc" id="L128">            TokenTypes.LITERAL_WHILE,</span>
<span class="fc" id="L129">            TokenTypes.LITERAL_DO,</span>
<span class="fc" id="L130">            TokenTypes.LITERAL_CATCH,</span>
<span class="fc" id="L131">            TokenTypes.LITERAL_TRY,</span>
<span class="fc" id="L132">            TokenTypes.VARIABLE_DEF,</span>
<span class="fc" id="L133">            TokenTypes.PARAMETER_DEF,</span>
<span class="fc" id="L134">            TokenTypes.ENUM_DEF,</span>
<span class="fc" id="L135">            TokenTypes.ENUM_CONSTANT_DEF,</span>
<span class="fc" id="L136">            TokenTypes.EXPR,</span>
<span class="fc" id="L137">            TokenTypes.STATIC_INIT,</span>
<span class="fc" id="L138">            TokenTypes.INSTANCE_INIT,</span>
<span class="fc" id="L139">            TokenTypes.LITERAL_NEW,</span>
<span class="fc" id="L140">            TokenTypes.LITERAL_THIS,</span>
<span class="fc" id="L141">            TokenTypes.CTOR_DEF,</span>
<span class="fc" id="L142">            TokenTypes.TYPE,</span>
<span class="fc" id="L143">            TokenTypes.TYPE_ARGUMENT,</span>
<span class="fc" id="L144">            TokenTypes.TYPE_PARAMETER,</span>
<span class="fc" id="L145">            TokenTypes.INTERFACE_DEF,</span>
<span class="fc" id="L146">            TokenTypes.LITERAL_SUPER,</span>
        };
    }

    @Override
    public int[] getDefaultTokens() {
<span class="fc" id="L152">        return getAcceptableTokens();</span>
    }

    @Override
    public int[] getRequiredTokens() {
<span class="fc" id="L157">        return getAcceptableTokens();</span>
    }

    @Override
    public void beginTree(DetailAST rootAST) {
<span class="fc" id="L162">        currentFrame = new Frame(null);</span>

<span class="fc" id="L164">        Arrays.sort(FRAME_TOKENS);</span>
<span class="fc" id="L165">    }</span>

    @Override
    public void visitToken(final DetailAST ast) {
<span class="fc bfc" id="L169" title="All 9 branches covered.">        switch (ast.getType()) {</span>
            case TokenTypes.VARIABLE_DEF:
            case TokenTypes.PARAMETER_DEF:
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                currentFrame.addField(ast);</span>
<span class="fc" id="L173">                break;</span>
            case TokenTypes.EXPR:
<span class="pc bpc" id="L175" title="1 of 2 branches missed.">                currentFrame.addExpr(ast);</span>
<span class="fc" id="L176">                break;</span>
            case TokenTypes.LITERAL_SUPER:
            case TokenTypes.LITERAL_THIS:
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">                currentFrame.hasLiteralThisOrSuper = true;</span>
<span class="fc" id="L180">                break;</span>
            case TokenTypes.TYPE:
            case TokenTypes.TYPE_ARGUMENT:
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">                final Optional&lt;DetailAST&gt; firstChild = Optional.fromNullable(ast.getFirstChild());</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                if (firstChild.isPresent()</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                        &amp;&amp; firstChild.get().getType() == TokenTypes.IDENT) {</span>
<span class="fc" id="L186">                    currentFrame.addType(firstChild.get().getText());</span>
                }
<span class="fc" id="L188">                break;</span>
            case TokenTypes.TYPE_PARAMETER:
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">                currentFrame.addTypeVariable(ast.getFirstChild().getText());</span>
<span class="fc" id="L191">                break;</span>
            case TokenTypes.METHOD_DEF:
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">                Frame frame = createMethodFrame(currentFrame, ast);</span>

<span class="fc" id="L195">                currentFrame.addMethod(ast);</span>
<span class="fc" id="L196">                currentFrame.addChild(frame);</span>
<span class="fc" id="L197">                currentFrame = frame;</span>
<span class="fc" id="L198">                break;</span>
            case TokenTypes.LITERAL_NEW:
<span class="pc bpc" id="L200" title="1 of 4 branches missed.">                if (isAnonymousClass(ast)) {</span>
<span class="fc" id="L201">                    frame = new Frame(currentFrame);</span>
                    // anonymous classes can't have static methods
<span class="fc" id="L203">                    frame.isShouldBeChecked = false;</span>

<span class="fc" id="L205">                    currentFrame.addChild(frame);</span>
<span class="fc" id="L206">                    currentFrame = frame;</span>
                }
<span class="fc" id="L208">                break;</span>
            case TokenTypes.ENUM_CONSTANT_DEF:
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">                frame = new Frame(currentFrame);</span>
                // ENUM_CONSTANT_DEF can't have static methods
<span class="fc" id="L212">                frame.isShouldBeChecked = false;</span>

<span class="fc" id="L214">                currentFrame.addEnumConst(ast);</span>
<span class="fc" id="L215">                currentFrame.addChild(frame);</span>
<span class="fc" id="L216">                currentFrame = frame;</span>
<span class="fc" id="L217">                break;</span>
            default:
<span class="pc bpc" id="L219" title="1 of 2 branches missed.">                frame = createFrame(currentFrame, ast);</span>

<span class="fc" id="L221">                currentFrame.addChild(frame);</span>
<span class="fc" id="L222">                currentFrame = frame;</span>
        }
<span class="fc" id="L224">    }</span>

    @Override
    public void leaveToken(DetailAST ast) {
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (isFrame(ast)</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">                || isAnonymousClass(ast)) {</span>
<span class="fc" id="L230">            currentFrame = currentFrame.parent;</span>
        }
<span class="fc" id="L232">    }</span>

    @Override
    public void finishTree(DetailAST ast) {
        // result of checkFrame() is only used while checking methods and not needed here
        // as we start from the root of the Frame tree
<span class="fc" id="L238">        checkFrame(currentFrame);</span>
<span class="fc" id="L239">    }</span>

    /**
     * Create a new Frame from METHOD_DEF ast.
     * @param ast METHOD_DEF ast.
     * @param parentFrame the parent frame for a new frame.
     * @return a new frame with the set fields.
     */
    private Frame createMethodFrame(Frame parentFrame, DetailAST ast) {
<span class="fc" id="L248">        final DetailAST modifiersAst = ast.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc" id="L249">        final String methodName = ast.findFirstToken(TokenTypes.IDENT).getText();</span>
<span class="fc" id="L250">        final Frame frame = new Frame(parentFrame);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">        if (modifiersAst.findFirstToken(TokenTypes.LITERAL_PRIVATE) != null</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                &amp;&amp; modifiersAst.findFirstToken(TokenTypes.LITERAL_STATIC) == null</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">                &amp;&amp; !skippedMethods.contains(methodName)) {</span>
<span class="fc" id="L254">            frame.isPrivateMethod = true;</span>
<span class="fc" id="L255">            frame.ast = ast;</span>
<span class="fc" id="L256">            frame.frameName = getIdentText(ast);</span>
<span class="fc" id="L257">        }</span>
        else {
            // non-private or static methods are not checked and can't have static methods
            // because local classes cannot be declared as static
<span class="fc" id="L261">            frame.isShouldBeChecked = false;</span>
        }
<span class="fc" id="L263">        return frame;</span>
    }

    /**
     * Check whether the ast is an anonymous class.
     * @param ast the ast to check.
     * @return if the checked ast is an anonymous class.
     */
    private static boolean isAnonymousClass(DetailAST ast) {
<span class="fc" id="L272">        final int astType = ast.getType();</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">        return astType == TokenTypes.LITERAL_NEW</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">                &amp;&amp; ast.findFirstToken(TokenTypes.OBJBLOCK) != null;</span>
    }

    /**
     * Create a new Frame from CLASS_DEF, LITERAL_IF, LITERAL_FOR, LITERAL_WHILE, LITERAL_DO,
     * LITERAL_CATCH, LITERAL_TRY, CTOR_DEF, ENUM_DEF.
     * @param ast the processed ast.
     * @param parentFrame the parent frame for a new frame.
     * @return a new frame with the set fields.
     */
    private static Frame createFrame(Frame parentFrame, DetailAST ast) {
<span class="fc" id="L285">        final Frame frame = new Frame(parentFrame);</span>
<span class="fc" id="L286">        final int astType = ast.getType();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (astType == TokenTypes.CLASS_DEF</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">                || astType == TokenTypes.ENUM_DEF) {</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (astType == TokenTypes.CLASS_DEF</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                    &amp;&amp; !ScopeUtil.isOuterMostType(ast)</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                    &amp;&amp; !hasStaticModifier(ast)) {</span>
                // local and inner classes can't have static methods
<span class="fc" id="L293">                frame.isShouldBeChecked = false;</span>
            }
<span class="fc" id="L295">            frame.frameName = getIdentText(ast);</span>
<span class="fc" id="L296">            frame.isClassOrEnum = true;</span>
<span class="fc" id="L297">        }</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        else if (astType == TokenTypes.STATIC_INIT</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">                || astType == TokenTypes.INSTANCE_INIT</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                || astType == TokenTypes.CTOR_DEF</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">                || astType == TokenTypes.INTERFACE_DEF) {</span>
<span class="fc" id="L302">            frame.isShouldBeChecked = false;</span>
        }
<span class="fc" id="L304">        return frame;</span>
    }

    /**
     * Check whether the ast is a Frame.
     * @param ast the ast to check.
     * @return true if the checked ast is a Frame.
     */
    private static boolean isFrame(DetailAST ast) {
<span class="fc" id="L313">        final int astType = ast.getType();</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        return Arrays.binarySearch(FRAME_TOKENS, astType) &gt;= 0;</span>
    }

    /**
     * Check whether the frame or its parent, which is a private method,
     * is a static method candidate.
     * @param parentFrame the frame to check.
     * @return true if the frame or its parent, which is a private method,
     *     is a static method candidate.
     */
    private boolean checkFrame(Frame parentFrame) {
<span class="fc" id="L325">        boolean isStaticCandidate = true;</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (Frame frame: parentFrame.children) {</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (frame.isShouldBeChecked) {</span>
<span class="fc" id="L328">                isStaticCandidate = checkFrame(frame);</span>
<span class="fc bfc" id="L329" title="All 2 branches covered.">                if (!frame.isClassOrEnum) {</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">                    isStaticCandidate = isStaticCandidate</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">                            &amp;&amp; !frame.hasLiteralThisOrSuper</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">                            &amp;&amp; isFrameExpressionsAcceptable(frame)</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">                            &amp;&amp; isFrameTypesAcceptable(frame);</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">                    if (frame.isPrivateMethod) {</span>
<span class="fc bfc" id="L335" title="All 2 branches covered.">                        if (isStaticCandidate) {</span>
<span class="fc" id="L336">                            log(frame.ast, MSG_KEY, frame.frameName);</span>
                        }
<span class="fc" id="L338">                    }</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">                    else if (!isStaticCandidate) {</span>
<span class="fc" id="L340">                        break;</span>
                    }
                }
            }
        }
<span class="fc" id="L345">        return isStaticCandidate;</span>
    }

    /**
     * Get the name of the field.
     * @param field to get the name from.
     * @return name of the field.
     */
    private static String getIdentText(DetailAST field) {
<span class="fc" id="L354">        return field.findFirstToken(TokenTypes.IDENT).getText();</span>
    }

    /**
     * Whether the ast has static modifier.
     * @param ast the ast to check.
     * @return true if the ast has static modifier.
     */
    private static boolean hasStaticModifier(DetailAST ast) {
<span class="fc bfc" id="L363" title="All 2 branches covered.">        return ast.findFirstToken(TokenTypes.MODIFIERS)</span>
<span class="fc" id="L364">            .findFirstToken(TokenTypes.LITERAL_STATIC) != null;</span>
    }

    /**
     * Check expressions in the given frame for being acceptable is static methods.
     * @param frame the frame to check.
     * @return true if the currently checked method
     *     is still a static method candidate.
     */
    private static boolean isFrameExpressionsAcceptable(final Frame frame) {
<span class="fc" id="L374">        final Predicate&lt;DetailAST&gt; predicate = new Predicate&lt;DetailAST&gt;() {</span>
            @Override
            public boolean apply(DetailAST ast) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">                return !isExprAcceptable(frame, ast);</span>
            }
        };
<span class="fc" id="L380">        final Optional&lt;DetailAST&gt; result = Iterables.tryFind(frame.expressions, predicate);</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">        return !result.isPresent();</span>
    }

    /**
     * Check types in the given frame for being acceptable in static methods.
     * @param frame the frame to check.
     * @return true if the currently checked method
     *     is still a static method candidate.
     */
    private static boolean isFrameTypesAcceptable(final Frame frame) {
<span class="fc" id="L391">        final Predicate&lt;String&gt; predicate = new Predicate&lt;String&gt;() {</span>
            @Override
            public boolean apply(String type) {
<span class="fc" id="L394">                final Optional&lt;Frame&gt; typeFrame = findFrameByName(frame, type);</span>
<span class="fc bfc" id="L395" title="All 4 branches covered.">                return typeFrame.isPresent() &amp;&amp; !typeFrame.get().isShouldBeChecked</span>
<span class="fc bfc" id="L396" title="All 2 branches covered.">                        || findTypeVariable(frame, type);</span>
            }
        };
<span class="fc" id="L399">        final Optional&lt;String&gt; result = Iterables.tryFind(frame.types, predicate);</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        return !result.isPresent();</span>
    }

    /**
     * Check whether the expression only contains fields and method calls accepted
     * in static methods (which can be checked).
     * @param frame the frame where the expression is located.
     * @param expr the expression to check.
     * @return true if the currently checked method
     *     is still a static method candidate.
     */
    private static boolean isExprAcceptable(Frame frame, DetailAST expr) {
<span class="fc" id="L412">        boolean isStaticCandidate = true;</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">        if (expr.branchContains(TokenTypes.IDENT)) {</span>
<span class="fc" id="L414">            DetailAST childAst = expr.getFirstChild();</span>
<span class="fc bfc" id="L415" title="All 2 branches covered.">            while (childAst != null</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                    &amp;&amp; isStaticCandidate) {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                if (childAst.getType() == TokenTypes.METHOD_CALL) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    isStaticCandidate = isStaticMethod(frame, childAst)</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">                            &amp;&amp; isExprAcceptable(frame, childAst);</span>
<span class="fc" id="L420">                }</span>
<span class="fc bfc" id="L421" title="All 2 branches covered.">                else if (childAst.getType() == TokenTypes.IDENT</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">                        &amp;&amp; isIdentShouldBeChecked(expr)) {</span>
<span class="fc" id="L423">                    isStaticCandidate = isStaticFieldOrLocalVariable(frame, childAst);</span>
<span class="fc" id="L424">                }</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">                else if (childAst.getType() == TokenTypes.LITERAL_NEW) {</span>
<span class="fc" id="L426">                    final Optional&lt;Frame&gt; typeFrame = findFrameByName(</span>
<span class="fc" id="L427">                            frame, childAst.getFirstChild().getText());</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">                    isStaticCandidate = isTypeFrameShouldBeChecked(typeFrame)</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">                            &amp;&amp; isExprAcceptable(frame, childAst);</span>
<span class="fc" id="L430">                }</span>
                else {
<span class="fc" id="L432">                    isStaticCandidate = isExprAcceptable(frame, childAst);</span>
                }
<span class="fc" id="L434">                childAst = childAst.getNextSibling();</span>
            }
        }
<span class="fc" id="L437">        return isStaticCandidate;</span>
    }

    /**
     * Find a frame with the specified name among the current frame and its parents.
     * @param frame the frame to start searching from.
     * @param frameName the specified name.
     * @return search result.
     */
    private static Optional&lt;Frame&gt; findFrameByName(Frame frame, String frameName) {
<span class="fc" id="L447">        Optional&lt;Frame&gt; result = Optional.absent();</span>
<span class="fc" id="L448">        Optional&lt;Frame&gt; parentFrame = Optional.of(frame.parent);</span>
<span class="fc bfc" id="L449" title="All 4 branches covered.">        while (parentFrame.isPresent() &amp;&amp; !result.isPresent()) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">            for (Frame child: parentFrame.get().children) {</span>
<span class="fc bfc" id="L451" title="All 2 branches covered.">                if (child.isClassOrEnum</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">                        &amp;&amp; frameName.equals(child.frameName)) {</span>
<span class="fc" id="L453">                    result = Optional.of(child);</span>
<span class="fc" id="L454">                    break;</span>
                }
            }
<span class="fc" id="L457">            parentFrame = Optional.fromNullable(parentFrame.get().parent);</span>
        }
<span class="fc" id="L459">        return result;</span>
    }

    /**
     * Find a type variable with the specified name.
     * @param frame the frame to start searching from.
     * @param type the name of the type variable to find.
     * @return true if a type variable with the specified name is found.
     */
    private static boolean findTypeVariable(Frame frame, String type) {
<span class="fc" id="L469">        boolean result = false;</span>
<span class="fc" id="L470">        Optional&lt;Frame&gt; searchFrame = Optional.of(frame);</span>
<span class="fc bfc" id="L471" title="All 4 branches covered.">        while (!result &amp;&amp; searchFrame.isPresent()) {</span>
<span class="fc" id="L472">            result = searchFrame.get().typeVariables.contains(type);</span>
<span class="fc" id="L473">            searchFrame = Optional.fromNullable(searchFrame.get().parent);</span>
        }
<span class="fc" id="L475">        return result;</span>
    }

    /**
     * Check whether a {@code static} method is called.
     * @param frame the frame where the method call is located.
     * @param methodCallAst METHOD_CALL ast.
     * @return true if a {@code static} method is called.
     */
    private static boolean isStaticMethod(Frame frame, DetailAST methodCallAst) {
<span class="fc" id="L485">        boolean result = false;</span>
<span class="fc" id="L486">        final DetailAST firstChild = methodCallAst.getFirstChild();</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">        if (firstChild.getType() == TokenTypes.DOT) {</span>
<span class="fc" id="L488">            final DetailAST objCalledOn = getTheLeftmostIdent(methodCallAst);</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">            if (objCalledOn.getType() == TokenTypes.IDENT) {</span>
<span class="fc" id="L490">                final Optional&lt;DetailAST&gt; field = findField(frame, objCalledOn);</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">                if (field.isPresent()) {</span>
<span class="fc" id="L492">                    result = isAcceptableField(field.get());</span>
<span class="fc" id="L493">                }</span>
<span class="fc bfc" id="L494" title="All 2 branches covered.">                else if (findFrameByName(frame, objCalledOn.getText()).isPresent()) {</span>
<span class="fc" id="L495">                    result = true;</span>
                }
<span class="fc" id="L497">            }</span>
            else {
<span class="fc" id="L499">                result = true;</span>
            }
<span class="fc" id="L501">        }</span>
        else {
<span class="fc" id="L503">            result = findStaticMethod(frame, methodCallAst, firstChild.getText());</span>
        }
<span class="fc" id="L505">        return result;</span>
    }

    /**
     * Determine whether the method call should be checked.
     * @param parentAst parent ast of the ident.
     * @return true, if LITERAL_THIS is used or the usage is too complex to check.
     */
    private static boolean isIdentShouldBeChecked(DetailAST parentAst) {
<span class="fc" id="L514">        final int parentAstType = parentAst.getType();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">        return parentAstType != TokenTypes.LITERAL_NEW</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">                &amp;&amp; parentAstType != TokenTypes.TYPE</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">                &amp;&amp; parentAstType != TokenTypes.METHOD_DEF;</span>
    }

    /**
     * Check whether a {@code static} field or a local variable is used.
     * @param frame the frame where the field is located.
     * @param identAst the identifier ast of the checked field.
     * @return true if the field is {@code static} or local.
     */
    private static boolean isStaticFieldOrLocalVariable(Frame frame, DetailAST identAst) {
        final boolean result;
<span class="fc" id="L528">        final int parentType = identAst.getParent().getType();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (parentType == TokenTypes.DOT) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">            if (identAst.getNextSibling() == null) {</span>
<span class="fc" id="L531">                result = true;</span>
<span class="fc" id="L532">            }</span>
            else {
<span class="fc" id="L534">                final Optional&lt;DetailAST&gt; field = findField(frame, identAst);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">                if (field.isPresent()) {</span>
<span class="fc" id="L536">                    result = isAcceptableField(field.get());</span>
<span class="fc" id="L537">                }</span>
                else {
<span class="fc" id="L539">                    result = findFrameByName(frame, identAst.getText()).isPresent();</span>
                }
            }
<span class="fc" id="L542">        }</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">        else if (parentType == TokenTypes.METHOD_CALL) {</span>
<span class="fc" id="L544">            result = true;</span>
<span class="fc" id="L545">        }</span>
        else {
<span class="fc" id="L547">            final Optional&lt;DetailAST&gt; field = findField(frame, identAst);</span>
<span class="fc bfc" id="L548" title="All 4 branches covered.">            result = field.isPresent() &amp;&amp; isAcceptableField(field.get());</span>
        }
<span class="fc" id="L550">        return result;</span>
    }

    /**
     * Whether the type frame should be checked.
     * @param typeFrame the frame of the type to check.
     * @return true if the type frame should be checked.
     */
    private static boolean isTypeFrameShouldBeChecked(final Optional&lt;Frame&gt; typeFrame) {
<span class="fc bfc" id="L559" title="All 2 branches covered.">        return !typeFrame.isPresent()</span>
<span class="fc bfc" id="L560" title="All 2 branches covered.">                    || typeFrame.get().isShouldBeChecked;</span>
    }

    /**
     * Get the leftmost ident of the method call.
     * @param mCall METHOD_CALL to get ident from.
     * @return the leftmost's ident DetailAST.
     */
    private static DetailAST getTheLeftmostIdent(DetailAST mCall) {
<span class="fc" id="L569">        DetailAST result = mCall.getFirstChild();</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">        while (result.getChildCount() != 0</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                &amp;&amp; result.getType() != TokenTypes.METHOD_CALL) {</span>
<span class="fc" id="L572">            result = result.getFirstChild();</span>
        }
<span class="fc" id="L574">        return result;</span>
    }

    /**
     * Find a static field definition or local variable.
     * @param startFrame the frame to start searching from.
     * @param identAst the IDENT ast to check.
     * @return search result.
     */
    private static Optional&lt;DetailAST&gt; findField(Frame startFrame, DetailAST identAst) {
<span class="fc" id="L584">        Optional&lt;DetailAST&gt; result = Optional.absent();</span>
<span class="fc" id="L585">        Optional&lt;Frame&gt; frame = Optional.of(startFrame);</span>
<span class="fc" id="L586">        final String fieldName = identAst.getText();</span>
<span class="fc bfc" id="L587" title="All 4 branches covered.">        while (frame.isPresent() &amp;&amp; !result.isPresent()) {</span>
<span class="fc" id="L588">            final Optional&lt;DetailAST&gt; field = frame.get().findFieldInFrame(fieldName);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">            if (field.isPresent()) {</span>
<span class="fc bfc" id="L590" title="All 2 branches covered.">                if (!isLocalVariable(field.get())</span>
<span class="fc bfc" id="L591" title="All 2 branches covered.">                        || checkFieldLocation(field.get(), identAst)) {</span>
<span class="fc" id="L592">                    result = field;</span>
                }
<span class="fc" id="L594">            }</span>
            else {
<span class="fc" id="L596">                result = frame.get().findEnumConstInFrame(fieldName);</span>
            }
<span class="fc" id="L598">            frame = Optional.fromNullable(frame.get().parent);</span>
        }
<span class="fc" id="L600">        return result;</span>
    }

    /**
     * Check whether the field is acceptable is a {@code static} method.
     * @param field the checked field.
     * @return true if the checked field is acceptable is a {@code static} method.
     */
    private static boolean isAcceptableField(DetailAST field) {
<span class="fc" id="L609">        boolean result = false;</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">        if (isLocalVariable(field)</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">                || field.getType() == TokenTypes.ENUM_CONSTANT_DEF</span>
<span class="fc bfc" id="L612" title="All 2 branches covered.">                || hasStaticModifier(field)) {</span>
<span class="fc" id="L613">            result = true;</span>
        }
<span class="fc" id="L615">        return result;</span>
    }

    /**
     * Find a {@code static} method definition of the specified method call
     * and ensure that there are no non-{@code static} methods with the same name and
     * number of parameters in the current frame or its parents.
     * @param startFrame the frame to start searching from.
     * @param methodCall METHOD_CALL ast.
     * @param checkedMethodName the name of the called method.
     * @return true if a {@code static} method definition of the specified method call
     *     is found and no non-{@code static} with the same name and number of parameters found.
     */
    private static boolean findStaticMethod(Frame startFrame, DetailAST methodCall,
                                            String checkedMethodName) {
<span class="fc" id="L630">        final int argsNumber = methodCall.findFirstToken(TokenTypes.ELIST).getChildCount();</span>
<span class="fc" id="L631">        Optional&lt;Frame&gt; frame = Optional.of(startFrame);</span>

        // if we do not find neither static nor non-static method, then we cannot claim
        // that the checked method can be static
<span class="fc" id="L635">        boolean hasNonStaticMethod = false;</span>
<span class="fc" id="L636">        boolean hasStaticMethod = false;</span>
<span class="fc bfc" id="L637" title="All 2 branches covered.">        while (!hasNonStaticMethod</span>
<span class="fc bfc" id="L638" title="All 2 branches covered.">                &amp;&amp; frame.isPresent()) {</span>
<span class="fc bfc" id="L639" title="All 2 branches covered.">            for (DetailAST method: frame.get().methods) {</span>
<span class="fc" id="L640">                final DetailAST parametersAst = method.findFirstToken(TokenTypes.PARAMETERS);</span>

<span class="fc bfc" id="L642" title="All 2 branches covered.">                if (checkedMethodName.equals(getIdentText(method))</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">                        &amp;&amp; (parametersAst.getChildCount() == argsNumber</span>
<span class="fc bfc" id="L644" title="All 2 branches covered.">                            || parametersAst.branchContains(TokenTypes.ELLIPSIS))) {</span>
<span class="fc" id="L645">                    final DetailAST modifiersAst = method.findFirstToken(TokenTypes.MODIFIERS);</span>

<span class="fc bfc" id="L647" title="All 2 branches covered.">                    if (modifiersAst.findFirstToken(TokenTypes.LITERAL_STATIC) == null) {</span>
                        // if a non-static method is found, then the checked method
                        // cannot be static
<span class="fc" id="L650">                        hasNonStaticMethod = true;</span>
<span class="fc" id="L651">                        break;</span>
                    }
                    else {
                        // if a static method is found, we keep searching for a similar
                        // non-static one to the end of the frame and if a non-static
                        // method is not found, then the checked method is still
                        // a static method candidate
<span class="fc" id="L658">                        hasStaticMethod = true;</span>
                    }
                }
            }
<span class="fc" id="L662">            frame = Optional.fromNullable(frame.get().parent);</span>
        }
<span class="fc bfc" id="L664" title="All 2 branches covered.">        return hasStaticMethod</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">                &amp;&amp; !hasNonStaticMethod;</span>
    }

    /**
     * Check whether the field is a local variable.
     * @param ast VARIABLE_DEF ast.
     * @return true if the field is a local variable.
     */
    private static boolean isLocalVariable(DetailAST ast) {
<span class="fc" id="L674">        final int parentType = ast.getParent().getParent().getType();</span>
<span class="fc bfc" id="L675" title="All 2 branches covered.">        return parentType != TokenTypes.CLASS_DEF</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">                &amp;&amp; parentType != TokenTypes.ENUM_DEF;</span>
    }

    /**
     * Check whether the field is declared before its usage in case of methods.
     * @param field field to check.
     * @param objCalledOn object equals method called on.
     * @return true if the field is declared before the method call.
     */
    private static boolean checkFieldLocation(DetailAST field, DetailAST objCalledOn) {
<span class="fc" id="L686">        boolean result = false;</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">        if (field.getLineNo() &lt; objCalledOn.getLineNo()</span>
<span class="fc bfc" id="L688" title="All 2 branches covered.">                || field.getLineNo() == objCalledOn.getLineNo()</span>
<span class="fc bfc" id="L689" title="All 2 branches covered.">                    &amp;&amp; field.getColumnNo() &lt; objCalledOn.getColumnNo()) {</span>
<span class="fc" id="L690">            result = true;</span>
        }
<span class="fc" id="L692">        return result;</span>
    }

    /**
     * Contains information about the frame.
     */
    private static class Frame {

        /** Name of the class, enum or method. */
        private String frameName;

        /** Parent frame. */
        private final Frame parent;

        /** List of frame's children. */
<span class="fc" id="L707">        private final List&lt;Frame&gt; children = new LinkedList&lt;&gt;();</span>

        /** List of fields. */
<span class="fc" id="L710">        private final List&lt;DetailAST&gt; fields = new LinkedList&lt;&gt;();</span>

        /** List of methods. */
<span class="fc" id="L713">        private final List&lt;DetailAST&gt; methods = new LinkedList&lt;&gt;();</span>

        /** List of typeVariables. */
<span class="fc" id="L716">        private final List&lt;String&gt; typeVariables = new LinkedList&lt;&gt;();</span>

        /** List of method calls. */
<span class="fc" id="L719">        private final List&lt;DetailAST&gt; expressions = new ArrayList&lt;&gt;();</span>

        /** List of types. */
<span class="fc" id="L722">        private final Set&lt;String&gt; types = Sets.newHashSet();</span>

        /** Set of enumConstants. */
<span class="fc" id="L725">        private final Set&lt;DetailAST&gt; enumConstants = Sets.newHashSet();</span>

        /** Whether the frame is CLASS_DEF or ENUM_DEF. */
        private boolean isClassOrEnum;

        /** Whether the frame is {@code private} METHOD_DEF. */
        private boolean isPrivateMethod;

        /**
         * Whether the frame should be checked.
         * It is used in order not to check non-private methods, static methods
         * and frames, where static methods cannot be defined: local and inner classes,
         * constructors, anonymous classes, enum constant definitions, initializers.
         */
<span class="fc" id="L739">        private boolean isShouldBeChecked = true;</span>

        /** Whether the frame has LITERAL_THIS or LITERAL_SUPER. */
        private boolean hasLiteralThisOrSuper;

        /** AST where the frame is declared. */
        private DetailAST ast;

        /**
         * Creates new frame.
         * @param parent parent frame.
         */
<span class="fc" id="L751">        /* package */ Frame(Frame parent) {</span>
<span class="fc" id="L752">            this.parent = parent;</span>
<span class="fc" id="L753">        }</span>

        /**
         * Add method call to this Frame.
         * @param exprAst EXPR ast.
         */
        public void addExpr(DetailAST exprAst) {
<span class="fc" id="L760">            expressions.add(exprAst);</span>
<span class="fc" id="L761">        }</span>

        /**
         * Add child frame to this frame.
         * @param child frame to add.
         */
        public void addChild(Frame child) {
<span class="fc" id="L768">            children.add(child);</span>
<span class="fc" id="L769">        }</span>

        /**
         * Add field to this Frame.
         * @param field the ast of the field.
         */
        public void addField(DetailAST field) {
<span class="fc" id="L776">            fields.add(field);</span>
<span class="fc" id="L777">        }</span>

        /**
         * Add method definition to this frame.
         * @param method METHOD_DEF ast.
         */
        public void addMethod(DetailAST method) {
<span class="fc" id="L784">            methods.add(method);</span>
<span class="fc" id="L785">        }</span>

        /**
         * Add method call to this frame.
         * @param enumConst ENUM_CONST_DEF ast.
         */
        public void addEnumConst(DetailAST enumConst) {
<span class="fc" id="L792">            enumConstants.add(enumConst);</span>
<span class="fc" id="L793">        }</span>

        /**
         * Add type variable name to this frame.
         * @param typeVariable the type variable name.
         */
        public void addTypeVariable(String typeVariable) {
<span class="fc" id="L800">            typeVariables.add(typeVariable);</span>
<span class="fc" id="L801">        }</span>

        /**
         * Add type to this frame.
         * @param type the type name.
         */
        public void addType(String type) {
<span class="fc" id="L808">            types.add(type);</span>
<span class="fc" id="L809">        }</span>

        /**
         * Determine whether this Frame contains the field.
         * @param name the name of the field to check.
         * @return search result.
         */
        public Optional&lt;DetailAST&gt; findFieldInFrame(final String name) {
<span class="fc" id="L817">            final Predicate&lt;DetailAST&gt; predicate = new Predicate&lt;DetailAST&gt;() {</span>
                @Override
                public boolean apply(DetailAST field) {
<span class="fc" id="L820">                    return getIdentText(field).equals(name);</span>
                }
            };
<span class="fc" id="L823">            return Iterables.tryFind(fields, predicate);</span>
        }

        /**
         * Determine whether this Frame contains the enum constant.
         * @param name the name of the enum constant to check.
         * @return search result.
         */
        public Optional&lt;DetailAST&gt; findEnumConstInFrame(final String name) {
<span class="fc" id="L832">            final Predicate&lt;DetailAST&gt; predicate = new Predicate&lt;DetailAST&gt;() {</span>
                @Override
                public boolean apply(DetailAST enumConstant) {
<span class="fc" id="L835">                    return getIdentText(enumConstant).equals(name);</span>
                }
            };
<span class="fc" id="L838">            return Iterables.tryFind(enumConstants, predicate);</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>