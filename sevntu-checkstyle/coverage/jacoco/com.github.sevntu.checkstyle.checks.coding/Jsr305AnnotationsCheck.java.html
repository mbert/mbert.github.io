<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Jsr305AnnotationsCheck.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">sevntu-checks</a> &gt; <a href="index.source.html" class="el_package">com.github.sevntu.checkstyle.checks.coding</a> &gt; <span class="el_source">Jsr305AnnotationsCheck.java</span></div><h1>Jsr305AnnotationsCheck.java</h1><pre class="source lang-java linenums">////////////////////////////////////////////////////////////////////////////////
// checkstyle: Checks Java source code for adherence to a set of rules.
// Copyright (C) 2001-2019 the original author or authors.
//
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
////////////////////////////////////////////////////////////////////////////////

package com.github.sevntu.checkstyle.checks.coding;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import antlr.collections.AST;
import com.github.sevntu.checkstyle.SevntuUtil;
import com.puppycrawl.tools.checkstyle.api.AbstractCheck;
import com.puppycrawl.tools.checkstyle.api.DetailAST;
import com.puppycrawl.tools.checkstyle.api.FullIdent;
import com.puppycrawl.tools.checkstyle.api.TokenTypes;

/**
 * &lt;p&gt;
 * The &lt;a href=&quot;https://jcp.org/en/jsr/detail?id=305&quot;&gt;Jsr305 annotations&lt;/a&gt; (annotations for
 * software defect detection) contain a subset of &quot;nullness&quot; annotations that can be used to mark
 * parameters as possibly null ({@code @Nullable}) or always non-null ({@code @Nonnull}), function
 * return values as to be checked for null ({@code @CheckForNull}) or always non-null
 * ({@code @Nonnull}) including defaults on class level ({@code @ParametersAreNonnullByDefault},
 * {@code @ParametersAreNullableByDefault}, {@code @ReturnValuesAreNonnullByDefault}).
 * &lt;/p&gt;
 * &lt;p&gt;
 * Using these annotations a programmer can declare how the code is meant to behave, and static code
 * analysis (like e.g. FindBugs) can be used to verify that this is actually true. Also these
 * annotations help others understanding code more easily, e.g. if confrontend with an annotated
 * interface the necessity for null checks can easily be deducted from the annotations.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The Jsr305AnnotationsCheck supports enforcing the following code style:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;Every method declaration, implementation or lambda requires nullness annotations for all
 * parameters and return values except for primitive types (because a void or an int can never be
 * null anyway).&lt;/li&gt;
 * &lt;li&gt;The annotation can be made directly or applied through either inheritance from an already
 * annotated class or a annotation for class-wide defaults.&lt;/li&gt;
 * &lt;li&gt;Annotations need to make sense. For instance, a class-scope annotation cannot be used for a
 * method, and a method annotation cannot be used for a class.&lt;/li&gt;
 * &lt;li&gt;In overridden methods, the following rule applies (regardless of what was annotated in the
 * parent method): For parameter definitions {@code @Nonnull} annotation is always illegal because
 * being less &quot;nullable&quot; cannot be assumed for a parameter in an inherited method. Conversely
 * {@code @Nullable} is always allowed. For return values it is the other way round:
 * {@code @CheckForNull} is always illegal while {@code @Nonnull} is always legal.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The following configuration properties are supported:
 * &lt;/p&gt;
 * &lt;dl&gt;
 * &lt;dt&gt;{@code packages = com.github.sevntu.pkg1,com.github.sevntu.pkg2}&lt;/dt&gt;
 * &lt;dd&gt;Activate this check for a list of parent packages and their children.&lt;/dd&gt;
 * &lt;dt&gt;{@code excludePackages = com.github.sevntu.pkg1.sub1,com.github.sevntu.pkg1.sub2}&lt;/dt&gt;
 * &lt;dd&gt;Set packages excluded from checking. This setting can be useful if under the parent package
 * set with &quot;packages&quot; there are subpackages which should not be checked.&lt;/dd&gt;
 * &lt;dt&gt;{@code allowOverridingReturnValue = true}&lt;/dt&gt;
 * &lt;dd&gt;Annotating return values &quot;@CheckForNull&quot; in overridden methods is flagged as an error. When
 * setting the this property to true, this error will be ignored (useful for upgrading).&lt;/dd&gt;
 * &lt;dt&gt;{@code allowOverridingParameters = true}&lt;/dt&gt;
 * &lt;dd&gt;Annotating parameters &quot;@Nonnull&quot; in overridden methods is flagged as an error. When setting
 * this property to true, this error will be ignored (useful for upgrading).&lt;/dd&gt;
 * &lt;/dl&gt;
 * &lt;p&gt;
 * Example code:
 * &lt;/p&gt;
 * &lt;p&gt;
 * Configure the check so that it scans the packages of the classes we want to run this on:
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * &amp;lt;module name=&amp;quot;Jsr305Annotations&amp;quot;&amp;gt;
 *   &amp;lt;property name=&amp;quot;packages&amp;quot; value=&amp;quot;org,com&amp;quot;/&amp;gt;
 *   &amp;lt;/module&amp;gt;
 * &lt;/pre&gt;
 *
 *
 * &lt;pre&gt;
 * // Example 1: a class without any class-level annotations
 * class Class1 {
 *     &amp;#64;CheckForNull // Violation: obj2 not annotated!
 *     String method1(@Nullable Object obj1, Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     // Violation: return value not annotated
 *     String method2() {
 *         return &quot;&quot;;
 *     }
 * }
 *
 * // Example 2: a class with class-level annotations for parameters
 * &amp;#64;ParametersAreNonnullByDefault
 * class Class2 {
 *     &amp;#64;CheckForNull // Legal
 *     String method1(Object obj1, Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Nonnull // Legal
 *     String method2(Object obj1, @Nullable Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Nonnull // Violation, redefinition of obj2's nullness
 *     String method3(Object obj1, @Nonnull Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     // Violation: return value not annotated
 *     String method4() {
 *         return &quot;&quot;;
 *     }
 * }
 *
 * // Example 3: a class overriding some methods
 * class Class3 implements Interface1 {
 *     &amp;#64;Override // Legal
 *     public Object method1(Object obj1, Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Override
 *     &amp;#64;Nonnull // Legal, return value becomes less &quot;nullable&quot;
 *     public Object method2(Object obj1, Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Override // Violation: Setting a parameter to non-null in an overridden method
 *     public Object method3(@Nonnull Object obj1, Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Override // Legal: parameter obj2 becomes more &quot;nullable&quot;
 *     public Object method4(Object obj1, @Nullable Object obj2) {
 *         return &quot;&quot;;
 *     }
 *
 *     &amp;#64;Override
 *     &amp;#64;CheckForNull // Violation: return value becomes more &quot;nullable&quot;
 *     public Object method5() {
 *         return &quot;&quot;;
 *     }
 * }
 * &lt;/pre&gt;
 */
<span class="fc" id="L167">public class Jsr305AnnotationsCheck extends AbstractCheck {</span>

    /** Key for error message. */
    public static final String MSG_ILLEGAL_CLASS_LEVEL_ANNOTATION =
            &quot;jsr305.illegal.class.level.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_CONTRADICTING_CLASS_LEVEL_ANNOTATIONS =
            &quot;jsr305.contradicting.class.level.annotations&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_DEFINITIONS_WITH_CHECK =
            &quot;jsr305.param.definitions.with.check.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_DEFINITION_WITH_OVERRIDE =
            &quot;jsr305.param.definition.with.override.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_DEFINITION_WITH_NONNULL_BY_DEFAULT =
            &quot;jsr305.param.definition.with.nonnull.by.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_DEFINITION_WITH_NULLABLE_BY_DEFAULT =
            &quot;jsr305.param.definition.with.nullable.by.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_DEFINITION_WITH_RETURN_DEFAULT =
            &quot;jsr305.param.definition.with.return.values.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAM_NONNULL_AND_NULLABLE =
            &quot;jsr305.param.nonnull.and.nullable.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PRIMITIVES_WITH_NULLNESS_ANNOTATION =
            &quot;jsr305.primitives.with.nullness.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_OVERRIDDEN_WITH_INCREASED_CONSTRAINT =
            &quot;jsr305.overridden.definitions.with.increased.param.constraint&quot;;

    /** Key for error message. */
    public static final String MSG_REDUNDANT_NONNULL_PARAM_ANNOTATION =
            &quot;jsr305.redundant.nonnull.param.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_REDUNDANT_NULLABLE_PARAM_ANNOTATION =
            &quot;jsr305.redundant.nullable.param.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_PARAMETER_WITHOUT_NULLNESS_ANNOTATION =
            &quot;jsr305.parameter.without.nullness.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_RETURN_VALUE_WITH_NONNULL_BY_DEFAULT =
            &quot;jsr305.return.value.with.nonnull.by.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_RETURN_VALUE_WITH_NULLABLE =
            &quot;jsr305.return.value.with.nullable.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_CONTRADICTING_RETURN_VALUE_ANNOTATIONS =
            &quot;jsr305.contradicting.return.value.annotations&quot;;

    /** Key for error message. */
    public static final String MSG_OVERRIDDEN_METHOD_WITH_CHECK_RETURN_VALUE =
            &quot;jsr305.overridden.method.with.check.return.value.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_REDUNDANT_NONNULL_BY_DEFAULT_ANNOTATION =
            &quot;jsr305.redundant.nonnull.by.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_REDUNDANT_NULLABLE_BY_DEFAULT_ANNOTATION =
            &quot;jsr305.redundant.nullable.by.default.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_VOID_WITH_CHECK_RETURN_VALUE_ANNOTATION =
            &quot;jsr305.void.with.check.return.value.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_REDUNDANT_NONNULL_RETURN_ANNOTATION =
            &quot;jsr305.redundant.nonnull.return.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_RETURN_WITHOUT_NULLNESS_ANNOTATION =
            &quot;jsr305.return.without.nullness.annotation&quot;;

    /** Key for error message. */
    public static final String MSG_OVERRIDDEN_METHODS_ALLOW_ONLY_NONNULL =
            &quot;jsr305.overridden.methods.allow.only.nonnull&quot;;

    /** Key for error message. */
    public static final String MSG_NEED_TO_INHERIT_PARAM_ANNOTATIONS =
            &quot;jsr305.need.to.inherit.param.annotations&quot;;

    /** Key for error message. */
    public static final String MSG_CONSTRUCTOR_WITH_RETURN_ANNOTATION =
            &quot;jsr305.constructor.with.return.annotation&quot;;

    /** Package name. */
    private static final String PKG_JAVAX_ANNOTATION = &quot;javax.annotation&quot;;

    /**
     * Class NullnessAnnotation. The annotations we consider as &quot;nullness-relevant&quot;.
     */
<span class="pc" id="L275">    protected enum NullnessAnnotation {</span>

        /** Override. */
<span class="fc" id="L278">        OVERRIDE(&quot;Override&quot;, &quot;java.lang&quot;),</span>
        /** CheckForNull. */
<span class="fc" id="L280">        CHECK_FOR_NULL(&quot;CheckForNull&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** Nullable. */
<span class="fc" id="L282">        NULLABLE(&quot;Nullable&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** Nonnull. */
<span class="fc" id="L284">        NONNULL(&quot;Nonnull&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** CheckReturnValue. */
<span class="fc" id="L286">        CHECK_RETURN_VALUE(&quot;CheckReturnValue&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** ParametersAreNonnullByDefault. */
<span class="fc" id="L288">        PARAMETERS_ARE_NONNULL_BY_DEFAULT(&quot;ParametersAreNonnullByDefault&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** ParametersAreNullableByDefault. */
<span class="fc" id="L290">        PARAMETERS_ARE_NULLABLE_BY_DEFAULT(&quot;ParametersAreNullableByDefault&quot;, PKG_JAVAX_ANNOTATION),</span>
        /** ReturnValuesAreNonnullByDefault. */
<span class="fc" id="L292">        RETURN_VALUES_ARE_NONNULL_BY_DEFAULT(&quot;ReturnValuesAreNonnullByDefault&quot;,</span>
                &quot;edu.umd.cs.findbugs.annotations&quot;);

        /** The annotation's name. */
        private final String annotationName;

        /** The annotation's fully qualified class name. */
        private final String fullyQualifiedClassName;

        /**
         * Constructor.
         * @param annotationName
         *        the annotation's name
         * @param packageName
         *        the package name
         */
<span class="fc" id="L308">        NullnessAnnotation(final String annotationName, final String packageName) {</span>
<span class="fc" id="L309">            this.annotationName = annotationName;</span>
<span class="fc" id="L310">            this.fullyQualifiedClassName = packageName + &quot;.&quot; + annotationName;</span>
<span class="fc" id="L311">        }</span>

    }

    /** The map of annotations against their respective names. */
    private static final Map&lt;String, NullnessAnnotation&gt; STRING2ANNOTATION =
<span class="fc" id="L317">            createString2AnnotationMap();</span>

    /** The modifiers of interest. */
<span class="fc" id="L320">    private static final int[] DEFAULT_MODIFIERS = {</span>
        TokenTypes.PARAMETER_DEF,
        TokenTypes.METHOD_DEF,
        TokenTypes.PACKAGE_DEF,
        TokenTypes.CTOR_DEF,
        TokenTypes.CLASS_DEF,
        TokenTypes.INTERFACE_DEF,
        TokenTypes.ENUM_DEF,
    };

    /** Parameter: packages to check. */
<span class="fc" id="L331">    private String[] packages = new String[0];</span>
    /** Parameter: packages to exclude from checking. */
<span class="fc" id="L333">    private String[] excludePackages = new String[0];</span>
    /** Parameter: overriding return value annotations allowed. */
    private boolean allowOverridingReturnValue;
    /** Parameter: overriding parameter annotations allowed. */
    private boolean allowOverridingParameter;

    /** State, is a package excluded. */
    private boolean packageExcluded;

    @Override
    public final int[] getDefaultTokens() {
<span class="fc" id="L344">        return getAcceptableTokens();</span>
    }

    @Override
    public final int[] getRequiredTokens() {
<span class="fc" id="L349">        return new int[0];</span>
    }

    @Override
    public final int[] getAcceptableTokens() {
<span class="fc" id="L354">        return DEFAULT_MODIFIERS.clone();</span>
    }

    @Override
    public final void visitToken(final DetailAST ast) {
<span class="fc bfc" id="L359" title="All 2 branches covered.">        if (ast.getType() == TokenTypes.PACKAGE_DEF) {</span>
<span class="fc" id="L360">            final DetailAST nameAST = ast.getLastChild().getPreviousSibling();</span>
<span class="fc" id="L361">            packageExcluded = isPackageExcluded(FullIdent.createFullIdent(nameAST));</span>
<span class="fc" id="L362">        }</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        else if (!packageExcluded) {</span>
<span class="fc" id="L364">            final AbstractJsr305Handler handler = handleDefinition(ast);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">            if (handler != null) {</span>
<span class="fc" id="L366">                handler.check();</span>
            }
        }
<span class="fc" id="L369">    }</span>

    /**
     * Sets the included packages parameter.
     * @param packageNames
     *        the package names, comma separated
     */
    public void setPackages(final String... packageNames) {
<span class="fc" id="L377">        packages = transformToUnique(packageNames);</span>
<span class="fc" id="L378">    }</span>

    /**
     * Maps annotations to their respective names.
     * @return the map
     */
    private static Map&lt;String, NullnessAnnotation&gt; createString2AnnotationMap() {
<span class="fc" id="L385">        final Map&lt;String, NullnessAnnotation&gt; result = new HashMap&lt;&gt;();</span>

<span class="fc bfc" id="L387" title="All 2 branches covered.">        for (final NullnessAnnotation annotation : NullnessAnnotation.values()) {</span>
<span class="fc" id="L388">            result.put(annotation.annotationName, annotation);</span>
<span class="fc" id="L389">            result.put(annotation.fullyQualifiedClassName, annotation);</span>
        }

<span class="fc" id="L392">        return Collections.unmodifiableMap(result);</span>
    }

    /**
     * Sets the excluded packages parameter.
     * @param packageNames
     *        the package names, comma separated
     */
    public void setExcludePackages(final String... packageNames) {
<span class="fc" id="L401">        excludePackages = transformToUnique(packageNames);</span>
<span class="fc" id="L402">    }</span>

    /**
     * Removes duplicates from an array of strings.
     * @param input
     *        the array
     * @return a new, duplicate-free array
     */
    private static String[] transformToUnique(final String... input) {
<span class="fc" id="L411">        final Set&lt;String&gt; inputSet = new HashSet&lt;&gt;(Arrays.asList(input));</span>
<span class="fc" id="L412">        return inputSet.toArray(new String[0]);</span>
    }

    /**
     * Checks whether a package is excluded.
     * @param fullIdent
     *        the identifier
     * @return true if yes
     */
    protected boolean isPackageExcluded(final FullIdent fullIdent) {
<span class="fc" id="L422">        Boolean result = null;</span>
<span class="fc" id="L423">        final String packageName = fullIdent.getText();</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">        for (final String excludesPackageName : excludePackages) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">            if (packageName.startsWith(excludesPackageName)) {</span>
<span class="fc" id="L426">                result = true;</span>
<span class="fc" id="L427">                break;</span>
            }
        }
<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">            for (final String includePackageName : packages) {</span>
<span class="fc bfc" id="L432" title="All 2 branches covered.">                if (packageName.startsWith(includePackageName)) {</span>
<span class="fc" id="L433">                    result = false;</span>
<span class="fc" id="L434">                    break;</span>
                }
            }
        }
<span class="fc bfc" id="L438" title="All 2 branches covered.">        if (result == null) {</span>
<span class="fc" id="L439">            result = true;</span>
        }
<span class="fc" id="L441">        return result;</span>
    }

    /**
     * Returns the check to use for a given definition.
     * @param ast
     *        the ast
     * @return the check.
     */
    protected AbstractJsr305Handler handleDefinition(final DetailAST ast) {

        // no definition in catch clause
<span class="fc" id="L453">        final DetailAST parent = ast.getParent();</span>
<span class="fc" id="L454">        AbstractJsr305Handler result = null;</span>
<span class="fc bfc" id="L455" title="All 4 branches covered.">        if (parent == null || parent.getType() != TokenTypes.LITERAL_CATCH) {</span>
            // search modifiers
<span class="fc" id="L457">            final int type = ast.getType();</span>
<span class="pc bpc" id="L458" title="1 of 5 branches missed.">            switch (type) {</span>
                case TokenTypes.METHOD_DEF:
<span class="fc" id="L460">                    result = new MethodJsr305Handler(ast);</span>
<span class="fc" id="L461">                    break;</span>
                case TokenTypes.CTOR_DEF:
<span class="fc" id="L463">                    result = new ConstructorJsr305Handler(ast);</span>
<span class="fc" id="L464">                    break;</span>
                case TokenTypes.PARAMETER_DEF:
<span class="fc" id="L466">                    result = new ParameterJsr305Handler(ast);</span>
<span class="fc" id="L467">                    break;</span>
                case TokenTypes.CLASS_DEF:
                case TokenTypes.INTERFACE_DEF:
                case TokenTypes.ENUM_DEF:
<span class="fc" id="L471">                    result = new ClassJsr305Handler(ast);</span>
<span class="fc" id="L472">                    break;</span>
                default:
<span class="nc" id="L474">                    SevntuUtil.reportInvalidToken(ast.getType());</span>
                    break;
            }
        }
<span class="fc" id="L478">        return result;</span>
    }

    /**
     * Sets the parameter for allowing overriding return values.
     * @param newAllowOverridingReturnValue
     *        true if yes
     */
    public void setAllowOverridingReturnValue(final boolean newAllowOverridingReturnValue) {
<span class="fc" id="L487">        this.allowOverridingReturnValue = newAllowOverridingReturnValue;</span>
<span class="fc" id="L488">    }</span>

    /**
     * Sets the parameter for allowing overriding parameters.
     * @param newAllowOverridingParameter
     *        true if yes
     */
    public void setAllowOverridingParameter(final boolean newAllowOverridingParameter) {
<span class="fc" id="L496">        this.allowOverridingParameter = newAllowOverridingParameter;</span>
<span class="fc" id="L497">    }</span>

    /**
     * Find the nullness annotations.
     * @param ast
     *        the ast
     * @return the annotations.
     */
    private static Set&lt;NullnessAnnotation&gt; findAnnotations(final DetailAST ast) {
<span class="fc" id="L506">        final Set&lt;NullnessAnnotation&gt; result = new HashSet&lt;&gt;();</span>

<span class="fc" id="L508">        final DetailAST modifiers = ast.findFirstToken(TokenTypes.MODIFIERS);</span>
<span class="fc bfc" id="L509" title="All 2 branches covered.">        for (AST child = modifiers.getFirstChild(); child != null; child = child.getNextSibling()) {</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">            if (child.getType() == TokenTypes.ANNOTATION) {</span>
<span class="fc" id="L511">                addNextNullnessAnnotation(result, (DetailAST) child);</span>
            }
        }

<span class="fc" id="L515">        return result;</span>
    }

    /**
     * Adds the nullness annotation from the argument's first token if any.
     * @param result
     *        the result
     * @param ast
     *        the ast
     */
    private static void addNextNullnessAnnotation(final Set&lt;NullnessAnnotation&gt; result,
            DetailAST ast) {
<span class="fc" id="L527">        final DetailAST identifier = ast.findFirstToken(TokenTypes.IDENT);</span>
<span class="fc" id="L528">        final String annotationName = identifier.getText();</span>
<span class="fc" id="L529">        final NullnessAnnotation annotation = STRING2ANNOTATION.get(annotationName);</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        if (annotation != null) {</span>
<span class="fc" id="L531">            result.add(annotation);</span>
        }
<span class="fc" id="L533">    }</span>

    /**
     * Class ClassJsr305Handler. Checks a class.
     */
    private final class ClassJsr305Handler extends AbstractJsr305Handler {

        /**
         * Constructor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L545">        protected ClassJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L546">            super(ast);</span>
<span class="fc" id="L547">        }</span>

        /**
         * Run the actual check.
         */
        @Override
        protected void runcheck() {
<span class="fc" id="L554">            checkContainsAny(MSG_ILLEGAL_CLASS_LEVEL_ANNOTATION,</span>
                    NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.CHECK_RETURN_VALUE,
                    NullnessAnnotation.NONNULL, NullnessAnnotation.NULLABLE);
<span class="fc" id="L557">            checkContainsAll(MSG_CONTRADICTING_CLASS_LEVEL_ANNOTATIONS,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT,
                    NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT);
<span class="fc" id="L560">        }</span>

    }

    /**
     * Class ParameterJsr305Handler. Checks a parameter.
     */
    private final class ParameterJsr305Handler extends AbstractJsr305Handler {

        /**
         * Constructor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L574">        protected ParameterJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L575">            super(ast);</span>
<span class="fc" id="L576">        }</span>

        /**
         * Run the actual check.
         */
        @Override
        protected void runcheck() {
<span class="fc" id="L583">            checkContainsAny(MSG_PARAM_DEFINITIONS_WITH_CHECK,</span>
                    NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.CHECK_RETURN_VALUE);
<span class="fc" id="L585">            checkContainsAny(MSG_PARAM_DEFINITION_WITH_OVERRIDE,</span>
                    NullnessAnnotation.OVERRIDE);
<span class="fc" id="L587">            checkContainsAny(MSG_PARAM_DEFINITION_WITH_NONNULL_BY_DEFAULT,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT);
<span class="fc" id="L589">            checkContainsAny(MSG_PARAM_DEFINITION_WITH_NULLABLE_BY_DEFAULT,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT);
<span class="fc" id="L591">            checkContainsAny(MSG_PARAM_DEFINITION_WITH_RETURN_DEFAULT,</span>
                    NullnessAnnotation.RETURN_VALUES_ARE_NONNULL_BY_DEFAULT);
<span class="fc" id="L593">            checkContainsAll(MSG_PARAM_NONNULL_AND_NULLABLE,</span>
                    NullnessAnnotation.NONNULL, NullnessAnnotation.NULLABLE);

<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (isPrimitiveType()) {</span>
<span class="fc" id="L597">                checkContainsAny(MSG_PRIMITIVES_WITH_NULLNESS_ANNOTATION,</span>
                        NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.NONNULL,
                        NullnessAnnotation.NULLABLE);
            }
            else {
<span class="fc" id="L602">                final NullnessAnnotation firstAncestorAnnotation =</span>
<span class="fc" id="L603">                        getParentMethodOrClassAnnotation(</span>
                                    NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT,
                                    NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT);
<span class="fc" id="L606">                final boolean isMethodOverridden = isMethodOverridden();</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                final boolean parametersAreNonnullByDefault = firstAncestorAnnotation</span>
                        == NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT;
<span class="fc bfc" id="L609" title="All 2 branches covered.">                final boolean parametersAreNullableByDefault = firstAncestorAnnotation</span>
                        == NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT;

<span class="fc bfc" id="L612" title="All 4 branches covered.">                if (isMethodOverridden &amp;&amp; !allowOverridingParameter) {</span>
<span class="fc" id="L613">                    checkContainsAny(MSG_OVERRIDDEN_WITH_INCREASED_CONSTRAINT,</span>
                            NullnessAnnotation.NONNULL);
                }
<span class="fc bfc" id="L616" title="All 2 branches covered.">                if (parametersAreNonnullByDefault) {</span>
<span class="fc" id="L617">                    checkContainsAny(MSG_REDUNDANT_NONNULL_PARAM_ANNOTATION,</span>
                            NullnessAnnotation.NONNULL);
                }
<span class="fc bfc" id="L620" title="All 2 branches covered.">                if (parametersAreNullableByDefault) {</span>
<span class="fc" id="L621">                    checkContainsAny(MSG_REDUNDANT_NULLABLE_PARAM_ANNOTATION,</span>
                            NullnessAnnotation.NULLABLE);
                }

<span class="fc bfc" id="L625" title="All 6 branches covered.">                if (!isMethodOverridden &amp;&amp; !parametersAreNonnullByDefault</span>
                        &amp;&amp; !parametersAreNullableByDefault) {
<span class="fc" id="L627">                    checkContainsNone(MSG_PARAMETER_WITHOUT_NULLNESS_ANNOTATION,</span>
                            NullnessAnnotation.NONNULL, NullnessAnnotation.NULLABLE);
                }
            }
<span class="fc" id="L631">        }</span>
    }

    /**
     * Class AbstractMethodJsr305Handler. A check on a method or constructor (special case).
     */
    private abstract class AbstractMethodJsr305Handler extends AbstractJsr305Handler {

        /**
         * Constructor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L644">        protected AbstractMethodJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L645">            super(ast);</span>
<span class="fc" id="L646">        }</span>

        /**
         * Run the actual check.
         */
        @Override
        protected void runcheck() {
<span class="fc" id="L653">            checkContainsAll(MSG_CONTRADICTING_CLASS_LEVEL_ANNOTATIONS,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT,
                    NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT);
<span class="fc" id="L656">            runReturnAnnotationCheck();</span>
<span class="fc" id="L657">        }</span>

        /**
         * Run annotation check for return.
         */
        protected abstract void runReturnAnnotationCheck();

    }

    /**
     * Class MethodJsr305Handler. A check for a method.
     */
    private final class MethodJsr305Handler extends AbstractMethodJsr305Handler {

        /**
         * Constructor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L676">        protected MethodJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L677">            super(ast);</span>
<span class="fc" id="L678">        }</span>

        /**
         * Run annotation check for return.
         */
        @Override
        protected void runReturnAnnotationCheck() {
<span class="fc" id="L685">            checkContainsAny(MSG_RETURN_VALUE_WITH_NONNULL_BY_DEFAULT,</span>
                    NullnessAnnotation.RETURN_VALUES_ARE_NONNULL_BY_DEFAULT);
<span class="fc" id="L687">            checkContainsAny(MSG_RETURN_VALUE_WITH_NULLABLE,</span>
                    NullnessAnnotation.NULLABLE);
<span class="fc" id="L689">            checkContainsAll(MSG_CONTRADICTING_RETURN_VALUE_ANNOTATIONS, NullnessAnnotation.NONNULL,</span>
                    NullnessAnnotation.CHECK_FOR_NULL);
<span class="fc" id="L691">            checkContainsAll(MSG_OVERRIDDEN_METHOD_WITH_CHECK_RETURN_VALUE,</span>
                    NullnessAnnotation.CHECK_RETURN_VALUE, NullnessAnnotation.OVERRIDE);
<span class="fc" id="L693">            checkRedundancyDueToClassLevelAnnotation(MSG_REDUNDANT_NONNULL_BY_DEFAULT_ANNOTATION,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT);
<span class="fc" id="L695">            checkRedundancyDueToClassLevelAnnotation(MSG_REDUNDANT_NULLABLE_BY_DEFAULT_ANNOTATION,</span>
                    NullnessAnnotation.PARAMETERS_ARE_NULLABLE_BY_DEFAULT);

<span class="fc bfc" id="L698" title="All 2 branches covered.">            if (isVoid()) {</span>
<span class="fc" id="L699">                checkContainsAny(MSG_VOID_WITH_CHECK_RETURN_VALUE_ANNOTATION,</span>
                        NullnessAnnotation.CHECK_RETURN_VALUE);
            }
<span class="fc bfc" id="L702" title="All 2 branches covered.">            if (isPrimitiveType()) {</span>
<span class="fc" id="L703">                checkContainsAny(MSG_PRIMITIVES_WITH_NULLNESS_ANNOTATION,</span>
                        NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.NONNULL,
                        NullnessAnnotation.NULLABLE);
            }
            else {
<span class="fc" id="L708">                final NullnessAnnotation annotation = getParentMethodOrClassAnnotation(</span>
                        NullnessAnnotation.RETURN_VALUES_ARE_NONNULL_BY_DEFAULT);
<span class="fc bfc" id="L710" title="All 2 branches covered.">                final boolean returnValuesAreNonnullByDefault = annotation</span>
                        == NullnessAnnotation.RETURN_VALUES_ARE_NONNULL_BY_DEFAULT;
<span class="fc" id="L712">                final boolean isMethodOverridden = isMethodOverridden();</span>

<span class="fc bfc" id="L714" title="All 2 branches covered.">                if (returnValuesAreNonnullByDefault) {</span>
<span class="fc bfc" id="L715" title="All 2 branches covered.">                    if (!isMethodOverridden) {</span>
<span class="fc" id="L716">                        checkContainsAny(MSG_REDUNDANT_NONNULL_RETURN_ANNOTATION,</span>
                                NullnessAnnotation.NONNULL);
                    }
                }
                else {
<span class="fc" id="L721">                    checkContainsNone(MSG_RETURN_WITHOUT_NULLNESS_ANNOTATION,</span>
                            NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.NONNULL,
                            NullnessAnnotation.OVERRIDE);
                }

<span class="fc bfc" id="L726" title="All 4 branches covered.">                if (isMethodOverridden &amp;&amp; !allowOverridingReturnValue) {</span>
<span class="fc" id="L727">                    checkContainsAny(MSG_OVERRIDDEN_METHODS_ALLOW_ONLY_NONNULL,</span>
                            NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.NULLABLE);
                }

<span class="fc bfc" id="L731" title="All 2 branches covered.">                if (isMethodOverridden) {</span>
<span class="fc" id="L732">                    checkContainsAny(MSG_NEED_TO_INHERIT_PARAM_ANNOTATIONS,</span>
                            NullnessAnnotation.PARAMETERS_ARE_NONNULL_BY_DEFAULT);
                }
            }
<span class="fc" id="L736">        }</span>

    }

    /**
     * Class ConstructorJsr305Handler. Check a constructor.
     */
    private final class ConstructorJsr305Handler extends AbstractMethodJsr305Handler {

        /**
         * Constructor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L750">        protected ConstructorJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L751">            super(ast);</span>
<span class="fc" id="L752">        }</span>

        /**
         * Check for return type nullness annotations (which are illegal).
         */
        @Override
        protected void runReturnAnnotationCheck() {
<span class="fc" id="L759">            checkContainsAny(MSG_CONSTRUCTOR_WITH_RETURN_ANNOTATION,</span>
                    NullnessAnnotation.CHECK_FOR_NULL, NullnessAnnotation.CHECK_RETURN_VALUE,
                    NullnessAnnotation.NONNULL, NullnessAnnotation.NULLABLE,
                    NullnessAnnotation.OVERRIDE);
<span class="fc" id="L763">        }</span>

    }

    /**
     * An abstract check, the base for checks on parameters, methods, classes. Class
     * AbstractJsr305Check.
     */
    public abstract class AbstractJsr305Handler {

        /** Has an error been found. */
        private boolean errorFound;
        /** The found annotations. */
        private final Set&lt;NullnessAnnotation&gt; annotations;
        /** The ast. */
        private final DetailAST ast;

        /**
         * Construtor.
         * @param ast
         *        the ast
         */
<span class="fc" id="L785">        protected AbstractJsr305Handler(final DetailAST ast) {</span>
<span class="fc" id="L786">            this.ast = ast;</span>
<span class="fc" id="L787">            this.errorFound = false;</span>
<span class="fc" id="L788">            annotations = findAnnotation();</span>
<span class="fc" id="L789">        }</span>

        /**
         * Run the actual check.
         */
        public final void check() {
<span class="fc" id="L795">            runcheck();</span>
<span class="fc" id="L796">        }</span>

        /**
         * Run the actual check.
         */
        protected abstract void runcheck();

        /**
         * Emits an error if any of the given annotations are found.
         * @param msg
         *        the error message to emit
         * @param search
         *        the annotations to look for
         */
        protected void checkContainsAny(final String msg, final NullnessAnnotation... search) {
<span class="fc bfc" id="L811" title="All 4 branches covered.">            if (!errorFound &amp;&amp; containsAny(search)) {</span>
<span class="fc" id="L812">                error(msg);</span>
            }
<span class="fc" id="L814">        }</span>

        /**
         * Check whether any of the given annotations are found.
         * @param search
         *        the annotations to look for
         * @return true if yes
         */
        protected boolean containsAny(final NullnessAnnotation... search) {
<span class="fc" id="L823">            Boolean result = null;</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">            if (this.annotations.isEmpty()) {</span>
<span class="fc" id="L825">                result = false;</span>
            }
            else {
<span class="fc bfc" id="L828" title="All 2 branches covered.">                for (final NullnessAnnotation obj : search) {</span>
<span class="fc bfc" id="L829" title="All 2 branches covered.">                    if (this.annotations.contains(obj)) {</span>
<span class="fc" id="L830">                        result = true;</span>
<span class="fc" id="L831">                        break;</span>
                    }
                }
            }
<span class="fc bfc" id="L835" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L836">                result = false;</span>
            }
<span class="fc" id="L838">            return result;</span>
        }

        /**
         * Emits an error if all given annotations are found.
         * @param msg
         *        the error message to emit
         * @param search
         *        the annotations to look for
         */
        protected void checkContainsAll(final String msg, final NullnessAnnotation... search) {
<span class="fc bfc" id="L849" title="All 4 branches covered.">            if (!errorFound &amp;&amp; containsAll(search)) {</span>
<span class="fc" id="L850">                error(msg);</span>
            }
<span class="fc" id="L852">        }</span>

        /**
         * Emits an error if both this and the parent class have redundant nullness annotations.
         * @param msg
         *        the error message to emit
         * @param search
         *        the annotations to look for
         */
        protected void checkRedundancyDueToClassLevelAnnotation(final String msg,
                final NullnessAnnotation... search) {
<span class="fc bfc" id="L863" title="All 2 branches covered.">            if (!errorFound) {</span>
<span class="fc bfc" id="L864" title="All 2 branches covered.">                for (final NullnessAnnotation nullnessAnnotation : search) {</span>
<span class="fc" id="L865">                    final boolean thisIsAnnotated = this.annotations.contains(nullnessAnnotation);</span>
<span class="fc" id="L866">                    final boolean parentIsAnnotated =</span>
<span class="fc bfc" id="L867" title="All 2 branches covered.">                            getParentMethodOrClassAnnotation(nullnessAnnotation) != null;</span>
<span class="fc bfc" id="L868" title="All 4 branches covered.">                    if (thisIsAnnotated &amp;&amp; parentIsAnnotated) {</span>
<span class="fc" id="L869">                        error(msg);</span>
<span class="fc" id="L870">                        break;</span>
                    }
                }
            }
<span class="fc" id="L874">        }</span>

        /**
         * Check whether all the given annotations are present.
         * @param search
         *        the annotations to look for
         * @return true if yes
         */
        protected boolean containsAll(final NullnessAnnotation... search) {
<span class="fc" id="L883">            Boolean result = null;</span>
<span class="fc bfc" id="L884" title="All 2 branches covered.">            if (this.annotations.isEmpty()) {</span>
                // an empty list of annotations can never contain all
<span class="fc" id="L886">                result = false;</span>
            }
            else {
<span class="fc bfc" id="L889" title="All 2 branches covered.">                for (final NullnessAnnotation obj : search) {</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">                    if (!this.annotations.contains(obj)) {</span>
<span class="fc" id="L891">                        result = false;</span>
<span class="fc" id="L892">                        break;</span>
                    }
                }
            }
<span class="fc bfc" id="L896" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L897">                result = true;</span>
            }
<span class="fc" id="L899">            return result;</span>
        }

        /**
         * Make sure that none of the given annotations are present.
         * @param msg
         *        the error message to emit if one of the given annotations was found
         * @param search
         *        the annotations to look for
         */
        protected void checkContainsNone(final String msg,
                final NullnessAnnotation... search) {
<span class="fc bfc" id="L911" title="All 4 branches covered.">            if (!errorFound &amp;&amp; !containsAny(search)) {</span>
<span class="fc" id="L912">                error(msg);</span>
            }
<span class="fc" id="L914">        }</span>

        /**
         * Logs an error.
         *
         * @param msg
         *        the message
         */
        protected void reportError(final String msg) {
<span class="fc" id="L923">            log(ast, msg);</span>
<span class="fc" id="L924">        }</span>

        /**
         * Handle an error (log and set 'errorFound' to 'true').
         *
         * @param msg
         *        the error message
         */
        protected void error(final String msg) {
<span class="fc" id="L933">            reportError(msg);</span>
<span class="fc" id="L934">            errorFound = true;</span>
<span class="fc" id="L935">        }</span>

        /**
         * Is the current symbol a primitive type.
         * @return true if yes
         */
        protected boolean isPrimitiveType() {
<span class="fc" id="L942">            final DetailAST parameterType = ast.findFirstToken(TokenTypes.TYPE);</span>
            final boolean result;
<span class="fc" id="L944">            final DetailAST identToken = parameterType.getFirstChild();</span>

<span class="fc bfc" id="L946" title="All 2 branches covered.">            switch (identToken.getType()) {</span>
                case TokenTypes.LITERAL_BOOLEAN:
                case TokenTypes.LITERAL_INT:
                case TokenTypes.LITERAL_LONG:
                case TokenTypes.LITERAL_SHORT:
                case TokenTypes.LITERAL_BYTE:
                case TokenTypes.LITERAL_CHAR:
                case TokenTypes.LITERAL_VOID:
                case TokenTypes.LITERAL_DOUBLE:
                case TokenTypes.LITERAL_FLOAT:
<span class="fc bfc" id="L956" title="All 2 branches covered.">                    result = !isArrayOrElipsis(parameterType);</span>
<span class="fc" id="L957">                    break;</span>
                default:
<span class="fc" id="L959">                    result = false;</span>
            }
<span class="fc" id="L961">            return result;</span>
        }

        /**
         * Checks whether token is array or elipsis.
         * @param identToken
         *        the token
         * @return true if yes
         */
        protected boolean isArrayOrElipsis(final DetailAST identToken) {
<span class="fc" id="L971">            final DetailAST next = identToken.getNextSibling();</span>
            final boolean result;
<span class="fc bfc" id="L973" title="All 2 branches covered.">            switch (next.getType()) {</span>
                case TokenTypes.ARRAY_DECLARATOR:
                case TokenTypes.ELLIPSIS:
<span class="fc" id="L976">                    result = true;</span>
<span class="fc" id="L977">                    break;</span>
                default:
<span class="fc" id="L979">                    result = false;</span>
            }
<span class="fc" id="L981">            return result;</span>
        }

        /**
         * Is the current symbol of void type.
         * @return true if yes
         */
        protected boolean isVoid() {
<span class="fc" id="L989">            final DetailAST parameterType = ast.findFirstToken(TokenTypes.TYPE);</span>
            final boolean result;
<span class="fc" id="L991">            final DetailAST identToken = parameterType.getFirstChild();</span>
<span class="fc bfc" id="L992" title="All 2 branches covered.">            result = identToken.getType() == TokenTypes.LITERAL_VOID;</span>
<span class="fc" id="L993">            return result;</span>
        }

        /**
         * Find the nullness annotations.
         * @return the annotations.
         */
        private Set&lt;NullnessAnnotation&gt; findAnnotation() {
<span class="fc" id="L1001">            return findAnnotations(ast);</span>
        }

        /**
         * Gets the nullness annotation for the parent method or class.
         * @param annotationsToLookFor
         *        the annotations to look for.
         * @return the annotation or null if none was found
         */
        protected NullnessAnnotation
                getParentMethodOrClassAnnotation(final NullnessAnnotation... annotationsToLookFor) {

<span class="fc" id="L1013">            boolean finished = false;</span>
<span class="fc" id="L1014">            NullnessAnnotation result = null;</span>
<span class="fc bfc" id="L1015" title="All 4 branches covered.">            for (DetailAST current = ast.getParent(); current != null &amp;&amp; !finished; current =</span>
<span class="fc" id="L1016">                    current.getParent()) {</span>
<span class="fc" id="L1017">                final int tokenType = current.getType();</span>

<span class="fc bfc" id="L1019" title="All 2 branches covered.">                if (isPossibleTokenTypeForNullnessAnnotations(tokenType)) {</span>
<span class="fc" id="L1020">                    final Set&lt;NullnessAnnotation&gt; foundAndLookedFor =</span>
<span class="fc" id="L1021">                            collectLookedForAnnotations(current, annotationsToLookFor);</span>
<span class="fc bfc" id="L1022" title="All 2 branches covered.">                    if (foundAndLookedFor.size() == 1) {</span>
<span class="fc" id="L1023">                        result = foundAndLookedFor.iterator().next();</span>
<span class="fc" id="L1024">                        finished = true;</span>
                    }
<span class="fc bfc" id="L1026" title="All 2 branches covered.">                    else if (!foundAndLookedFor.isEmpty()) {</span>
<span class="fc" id="L1027">                        finished = true;</span>
                    }
                }
                // break on inner and anonymous classes/interfaces, we can't
                // handle inheritance correctly
<span class="fc bfc" id="L1032" title="All 8 branches covered.">                if (tokenType == TokenTypes.LITERAL_NEW || tokenType == TokenTypes.CLASS_DEF</span>
                        || tokenType == TokenTypes.INTERFACE_DEF
                        || tokenType == TokenTypes.ENUM_DEF) {
<span class="fc" id="L1035">                    finished = true;</span>
                }
            }
<span class="fc" id="L1038">            return result;</span>
        }

        /**
         * Is the current tokenType a possible type for nullness annotations.
         * @param tokenType the token type
         * @return true if yes
         */
        private boolean isPossibleTokenTypeForNullnessAnnotations(final int tokenType) {
<span class="fc bfc" id="L1047" title="All 10 branches covered.">            return tokenType == TokenTypes.CLASS_DEF || tokenType == TokenTypes.INTERFACE_DEF</span>
                    || tokenType == TokenTypes.METHOD_DEF || tokenType == TokenTypes.CTOR_DEF
                    || tokenType == TokenTypes.ENUM_DEF;
        }

        /**
         * Extracts all given annotations from the current ast.
         * @param current the current ast
         * @param annotationsToLookFor the annotations we are looking for
         * @return the annotations
         */
        protected Set&lt;NullnessAnnotation&gt; collectLookedForAnnotations(DetailAST current,
                final NullnessAnnotation... annotationsToLookFor) {
<span class="fc" id="L1060">            final Set&lt;NullnessAnnotation&gt; foundAnnotations = findAnnotations(current);</span>
<span class="fc" id="L1061">            final Set&lt;NullnessAnnotation&gt; foundAndLookedFor = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L1062" title="All 2 branches covered.">            for (final NullnessAnnotation nullnessAnnotation : annotationsToLookFor) {</span>
<span class="fc bfc" id="L1063" title="All 2 branches covered.">                if (foundAnnotations.contains(nullnessAnnotation)) {</span>
<span class="fc" id="L1064">                    foundAndLookedFor.add(nullnessAnnotation);</span>
                }
            }
<span class="fc" id="L1067">            return foundAndLookedFor;</span>
        }

        /**
         * Is the current method overridden.
         * @return true if yes
         */
        protected boolean isMethodOverridden() {
<span class="fc" id="L1075">            DetailAST current = ast;</span>
<span class="fc" id="L1076">            Boolean result = null;</span>
<span class="fc bfc" id="L1077" title="All 4 branches covered.">            for (; current != null &amp;&amp; result == null; current = current.getParent()) {</span>
<span class="fc bfc" id="L1078" title="All 3 branches covered.">                switch (current.getType()) {</span>
                    case TokenTypes.METHOD_DEF:
<span class="fc" id="L1080">                        result = findAnnotations(current).contains(NullnessAnnotation.OVERRIDE);</span>
<span class="fc" id="L1081">                        break;</span>
                    case TokenTypes.LAMBDA:
<span class="fc" id="L1083">                        result = true;</span>
<span class="fc" id="L1084">                        break;</span>
                    default:
                }
            }
<span class="fc bfc" id="L1088" title="All 2 branches covered.">            if (result == null) {</span>
<span class="fc" id="L1089">                result = false;</span>
            }
<span class="fc" id="L1091">            return result;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>